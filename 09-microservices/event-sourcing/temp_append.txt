
## Best Practices

### Event Design

- **Use explicit domain events**: Name events based on business language
- **Make events immutable**: Never modify events after creation
- **Include event metadata**: Add timestamps, correlation IDs, and causation IDs
- **Keep events small**: Prefer focused events over large payloads
- **Validate event schemas**: Ensure events conform to defined schemas

### Event Store Design

- **Use append-only storage**: Never update or delete events
- **Enforce ordering per aggregate**: Ensure events are ordered by version
- **Implement optimistic concurrency**: Use version checks to prevent conflicts
- **Choose appropriate storage**: EventStoreDB, PostgreSQL, or other options
- **Plan for scalability**: Design for high write throughput

### Snapshots

- **Snapshot periodically**: After N events or time interval
- **Store snapshot version**: Include event version for consistency
- **Use snapshots for replay**: Start replay from last snapshot
- **Keep snapshots consistent**: Ensure snapshots match event history
- **Monitor snapshot performance**: Track snapshot creation time

### Projections

- **Design for queries**: Build projections optimized for read patterns
- **Make projections rebuildable**: Allow complete rebuild from event log
- **Use idempotent handlers**: Handle duplicate events safely
- **Handle event ordering**: Process events in correct order
- **Monitor projection lag**: Track how far behind projections are

### Event Replay

- **Test replay procedures**: Verify replay works correctly
- **Use throttling**: Limit replay impact on production
- **Plan replay time**: Estimate how long replay will take
- **Use isolated environments**: Test replay in staging first
- **Monitor replay progress**: Track replay completion

### CQRS Integration

- **Separate read and write models**: Use different schemas for each
- **Scale independently**: Scale read and write sides separately
- **Handle eventual consistency**: Communicate staleness to users
- **Use read-your-writes**: When strong consistency is needed
- **Design for async updates**: Accept temporary inconsistency

### Schema Evolution

- **Never modify existing events**: Create new event types instead
- **Use upcasters**: Convert old event versions to new schemas
- **Deprecate gradually**: Mark old event types before removal
- **Maintain backward compatibility**: Support multiple event versions
- **Document schema changes**: Keep clear records of all changes

### Performance

- **Batch event writes**: Write multiple events together when possible
- **Use appropriate indexes**: Index for read patterns, not write patterns
- **Monitor event throughput**: Track events per second
- **Optimize replay**: Use snapshots to reduce replay time
- **Choose appropriate storage**: Match storage to workload

### Monitoring

- **Track event counts**: Monitor events per aggregate and type
- **Monitor projection lag**: Alert on large delays
- **Track replay performance**: Measure replay time and resource usage
- **Monitor event store health**: Track storage metrics
- **Set up alerts**: Notify on anomalies or failures

## Checklist

### Event Design
- [ ] Define event schemas
- [ ] Use explicit domain event names
- [ ] Include event metadata (timestamps, correlation IDs)
- [ ] Validate event payloads
- [ ] Document event types

### Event Store Setup
- [ ] Choose appropriate event store
- [ ] Configure append-only writes
- [ ] Implement optimistic concurrency
- [ ] Set up indexes for queries
- [ ] Configure replication for high availability

### Aggregate Design
- [ ] Define aggregate boundaries
- [ ] Implement business invariants
- [ ] Design event sequence
- [ ] Implement version checking
- [ ] Test aggregate behavior

### Snapshot Strategy
- [ ] Define snapshot frequency
- [ ] Implement snapshot creation
- [ ] Store snapshot versions
- [ ] Test replay from snapshots
- [ ] Monitor snapshot performance

### Projection Design
- [ ] Identify read patterns
- [ ] Design projection schemas
- [ ] Implement projection handlers
- [ ] Make projections idempotent
- [ ] Test projection rebuilds

### CQRS Setup
- [ ] Separate read and write models
- [ ] Configure separate databases if needed
- [ ] Implement command handlers
- [ ] Implement query handlers
- [ ] Handle eventual consistency

### Event Replay
- [ ] Design replay procedures
- [ ] Implement replay throttling
- [ ] Test replay in staging
- [ ] Plan replay windows
- [ ] Monitor replay progress

### Schema Evolution
- [ ] Define event versioning strategy
- [ ] Implement upcasters
- [ ] Plan deprecation process
- [ ] Maintain backward compatibility
- [ ] Document schema changes

### Monitoring
- [ ] Set up event metrics
- [ ] Monitor projection lag
- [ ] Track event throughput
- [ ] Configure alerts
- [ ] Create dashboards

### Testing
- [ ] Test aggregate behavior
- [ ] Test projection handlers
- [ ] Test event replay
- [ ] Test schema evolution
- [ ] Performance test event store

### Documentation
- [ ] Document event schemas
- [ ] Document aggregate design
- [ ] Document projection logic
- [ ] Create replay runbooks
- [ ] Maintain API documentation
